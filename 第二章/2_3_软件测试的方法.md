# § 2.3 - 软件测试的方法

## 一、静态测试与动态测试

### :one: 静态测试

**静态测试 (Static Testing)**：指的是**并不实际运行**被测试的软件，仅**静态**的检查**程序代码、软件界面以及项目文档**中可能存在的**错误与缺陷**的过程。

**静态测试主要检查以下三个位置**：

1. **程序代码**：[会在**下方**详细介绍]
2. **软件界面**：测试软件的**实际界面**与需求文档中的**说明界面**是否完全相符。
3. **项目文档**：测试**用户手册**与**需求说明文档**是否完全符合最终用户的实际需求。

**程序代码**方面主要检查以下几点：

1. **代码检查**：检查编码风格是否符合规范。
2. **静态结构分析**：检查算法是否仍有优化空间、程序函数逻辑是否存在错误等。[会在**下方**详细介绍]
3. **代码质量度量**：使用人工或软件工具检查程序代码质量是否合乎设计标准。

**静态结构分析**：指的是将软件的程序内部结构抽象为**图形** (例如**函数调用关系图、函数内部控制流图**等)，并对其进行结构层面的分析。**例图如下**：

![静态结构分析](https://github.com/Lingggao/Software-Testing-Basics/blob/master/%E7%AC%AC%E4%BA%8C%E7%AB%A0/2_3_%E9%9D%99%E6%80%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.png?raw=true)

**静态测试阶段的主要活动**：

- 检查**算法逻辑**是否正确。
- 检查**模块接口**是否正确。
- 检查函数是否对输入参数进行了**合法性检查**。
- 检查程序能否对**异常或错误**进行适当的处理。
- 检查代码**表达式与语句**是否准确并且**不存在二义性**。
- 检查**常量与全局变量**的使用是否符合规范。
- 检查**标识符**的使用是否符合规范。
- 检查程序**代码风格**的**一致性、规范性**。
- 检查代码是否仍然可以继续**优化** (**算法效率**是否足够高)。
- 检查代码**注释**是否**完整且规范**，是否可以准确的反映代码功能。

**示例**：

``` c++
#include<iostream>
max(float x,float y)
{
    float z;
    z=x>y?x:y;
  return z;
}
main()
{
    float a,b;
    int c;
    std::cin>>a>>b;
    c=max(a,b);
    std::cout<<"Max num is: "<<c<<std::endl;
}
```

> 注意：这是一段**不规范、包含错误**的待测试代码。

在上述代码块中，以下几点是**必须修改**的：

1. 函数没有任何注释。
2. max 函数的返回值存在错误。
3. main 函数中存在 float 精度丢失的问题。

以下几点是**建议修改**的：

1. main 函数自身没有返回值类型和参数列表。
2. 1 行代码应当只定义 1 个变量。
3. 代码风格不良，缩进混乱，应当多添加一些空格与换行。

**静态测试结束后，代码改进后的情况如下**：

``` c++
/*
    程序功能：求解两个实数中的最大值。
    作者：Ling Gao
    日期：2020.4.2
    学校：湖南理工学院
    院系：信息科学与工程学院
*/
#include <iostream>

//用途：返回变量 x 与 y 中的最大值。
float max(float x, float y)
{
    float z;
    z = x>y ? x:y;
    return z;
}

int main(int argc, char *argv[])
{
    float a,
    float b;
    float c;
    std::cin >> a >> b;
    c = max(a, b);
    std::cout << "Max num is: " << c << std::endl;
	
    return 0;
}
```

### :two: 动态测试

**动态测试 (Dynamic Testing)**：指的是**实际运行**被测试的软件，向其中**输入测试数据**，检查**实际输出结果**与**预期结果**是否**相符**的过程。**判断测试属于静态还是动态，仅需要确认是否实际运行了软件**。

**动态测试主要包括**：

1. **功能确认、接口测试**
2. **覆盖率分析**
3. **性能分析**
4. **内存分析**

以上方的代码块为例，当执行**动态测试**时，需要测试工程师**执行此程序**，输入**多组测试用例 (每组两个实数)**，确认程序是否可以**按照预期结果**准确的输出两实数中的最大数。

## 二、白盒测试与黑盒测试

**“黑盒测试”** 与 **“白盒测试”** 两种测试方法分别从两种**完全不同的角度**出发，反映了两种**截然不同的思路**。它们分别适用于**不同的测试阶段**。

### :one: 白盒测试

![在写了，在写了](https://th.bing.com/th?id=OIP.42HxzoZHDC56sK2g6u2D1QAAAA&pid=Api&rs=1)

在写了，在写了~

### :two: 黑盒测试

**黑盒测试** (亦称用户测试、功能测试、数据驱动测试)：指的是将待测试软件当作一个 **“打不开的黑盒子”**，在程序接口开展测试工作，**只检查软件功能是否满足规格说明文档**，根据软件功能需求来设计测试用例并执行测试。**集成、系统、验收测试流程一般都使用黑盒测试作为主要的方法**。

**黑盒测试正规概念**：黑盒测试是一种**从软件外部对软件实施的测试**，也称功能测试或基于规格说明的测试。其基本观点是：任何程序都可以看作是从输入定义域到输出值域的映射，这种观点将被测程序看作一个打不开的黑盒，黑盒里面的内容 (实现) 是完全不知道的，只知道软件要做什么。

**黑盒测试的特点**：

- 黑盒测试与软件的具体实现过程无关，如果实现过程发生了变化，测试用例与数据仍然可以正常使用。
- 黑盒测试的测试用例设计可以与软件的开发工作同时进行，可以压缩项目的总开发时间。

## 三、手工测试与自动化测试

![在写了，在写了](https://th.bing.com/th?id=OIP.42HxzoZHDC56sK2g6u2D1QAAAA&pid=Api&rs=1)

在写了，在写了~

---
[**回到顶部**](https://github.com/Lingggao/Software-Testing-Basics/blob/master/%E7%AC%AC%E4%BA%8C%E7%AB%A0/2_3_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%B9%E6%B3%95.md#-23---%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%B9%E6%B3%95)

[**下一章节：§ 2.4 - 软件测试用例详解**]()

[**回到主页**](https://github.com/Lingggao/Software-Testing-Basics#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80)