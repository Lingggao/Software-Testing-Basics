# § 2.3 - 软件测试的方法

## 一、静态测试与动态测试

### :one: 静态测试

**静态测试 (Static Testing)**：指的是**并不实际运行**被测试的软件，仅**静态**的检查**程序代码、软件界面以及项目文档**中可能存在的**错误与缺陷**的过程。

**静态测试主要检查以下三个位置**：

1. **程序代码**：[会在**下方**详细介绍]
2. **软件界面**：测试软件的**实际界面**与需求文档中的**说明界面**是否完全相符。
3. **项目文档**：测试**用户手册**与**需求说明文档**是否完全符合最终用户的实际需求。

**程序代码**方面主要检查以下几点：

1. **代码检查**：检查编码风格是否符合规范。
2. **静态结构分析**：检查算法是否仍有优化空间、程序函数逻辑是否存在错误等。[会在**下方**详细介绍]
3. **代码质量度量**：使用人工或软件工具检查程序代码质量是否合乎设计标准。

**静态结构分析**：指的是将软件的程序内部结构抽象为**图形** (例如**函数调用关系图、函数内部控制流图**等)，并对其进行结构层面的分析。**例图如下**：

![静态结构分析](https://github.com/Lingggao/Software-Testing-Basics/blob/master/%E7%AC%AC%E4%BA%8C%E7%AB%A0/2_3_%E9%9D%99%E6%80%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.png?raw=true)

**静态测试阶段的主要活动**：

- 检查**算法逻辑**是否正确。
- 检查**模块接口**是否正确。
- 检查函数是否对输入参数进行了**合法性检查**。
- 检查程序能否对**异常或错误**进行适当的处理。
- 检查代码**表达式与语句**是否准确并且**不存在二义性**。
- 检查**常量与全局变量**的使用是否符合规范。
- 检查**标识符**的使用是否符合规范。
- 检查程序**代码风格**的**一致性、规范性**。
- 检查代码是否仍然可以继续**优化** (**算法效率**是否足够高)。
- 检查代码**注释**是否**完整且规范**，是否可以准确的反映代码功能。

**示例**：

``` c++
#include<iostream>
max(float x,float y)
{
    float z;
    z=x>y?x:y;
  return z;
}
main()
{
    float a,b;
    int c;
    std::cin>>a>>b;
    c=max(a,b);
    std::cout<<"Max num is: "<<c<<std::endl;
}
```

> 注意：这是一段**不规范、包含错误**的待测试代码。

在上述代码块中，以下几点是**必须修改**的：

1. 函数没有任何注释。
2. max 函数的返回值存在错误。
3. main 函数中存在 float 精度丢失的问题。

以下几点是**建议修改**的：

1. main 函数自身没有返回值类型和参数列表。
2. 1 行代码应当只定义 1 个变量。
3. 代码风格不良，缩进混乱，应当多添加一些空格与换行。

**静态测试结束后，代码改进后的情况如下**：

``` c++
/*
    程序功能：求解两个实数中的最大值。
    作者：Ling Gao
    日期：2020 年 4 月 2 日
    学校：湖南理工学院
    院系：信息科学与工程学院
*/
#include <iostream>

//用途：返回变量 x 与 y 中的最大值。
float max(float x, float y)
{
    float z;
    z = x>y ? x:y;
	
    return z;
}

int main(int argc, char *argv[])
{
    float a,
    float b;
    float c;
    std::cin >> a >> b;
    c = max(a, b);
    std::cout << "Max num is: " << c << std::endl;
	
    return 0;
}
```

### :two: 动态测试

**动态测试 (Dynamic Testing)**：指的是**实际运行**被测试的软件，向其中**输入测试数据**，检查**实际输出结果**与**预期结果**是否**相符**的过程。**判断测试属于静态还是动态，仅需要确认是否实际运行了软件**。

**动态测试主要包括**：

1. **功能确认、接口测试**
2. **覆盖率分析**
3. **性能分析**
4. **内存分析**

以上方的代码块为例，当执行**动态测试**时，需要测试工程师**执行此程序**，输入**多组测试用例 (每组两个实数)**，确认程序是否可以**按照预期结果**准确的输出两实数中的最大数。

## 二、白盒测试与黑盒测试

**“黑盒测试”** 与 **“白盒测试”** 两种测试方法分别从两种**完全不同的角度**出发，反映了两种**截然不同的思路**。它们分别适用于**不同的测试阶段**。**黑盒测试既可以是动态测试，也可以是静态测试，白盒测试同样如此**。

### :one: 白盒测试

**白盒测试** (亦称程序员测试、结构测试、逻辑驱动测试)：指的是需要完全了解软件的**结构**与**处理过程**，按照软件的**内部逻辑**来测试软件，**检验软件中的每条路径能否按照规格说明文档中的规定或要求正常执行**。

### :two: 黑盒测试

**黑盒测试** (亦称用户测试、功能测试、数据驱动测试)：指的是将待测试软件当作一个 **“打不开的黑盒子”**，在程序接口开展测试工作，**只检查软件功能是否满足规格说明文档**，根据软件功能需求来设计测试用例并执行测试。**集成、系统、验收测试流程一般都使用黑盒测试作为主要的方法**。

**黑盒测试正规概念**：黑盒测试是一种**从软件外部对软件实施的测试**，也称功能测试或基于规格说明的测试。其基本观点是：任何程序都可以看作是从输入定义域到输出值域的映射，这种观点将被测程序看作一个打不开的黑盒，黑盒里面的内容 (实现) 是完全不知道的，只知道软件要做什么。

**黑盒测试的特点**：

- 黑盒测试与软件的具体实现过程无关，如果实现过程发生了变化，测试用例与数据仍然可以正常使用。
- 黑盒测试的测试用例设计可以与软件的开发工作同时进行，可以压缩项目的总开发时间。

## 三、手工测试与自动化测试

**常用自动化测试工具**：

1. **功能性**自动化测试工具
	- QuickTest Professional
	- Rational Robot
	- Compuware QARun
	- *等*
2. **性能**自动化测试工具
	- LoadRunner
	- MS WAS
	- Rational Robot
	- *等*

**主要理论**：

1. 手工测试与自动化测试都是**不可或缺**的，两者是**相辅相成**的关系。
2. 手工测试与自动化测试都**以测试用例为核心**。
3. 理论上，所有的手工测试都可以改为以自动化的方式来执行，不过应当考虑使用自动化测试工具带来的效率上的增益能否抵消掉项目资金的消耗。

---
[**回到顶部**](https://github.com/Lingggao/Software-Testing-Basics/blob/master/%E7%AC%AC%E4%BA%8C%E7%AB%A0/2_3_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%B9%E6%B3%95.md#-23---%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%B9%E6%B3%95)

[**下一章节：§ 2.4 - 软件测试用例详解**](https://github.com/Lingggao/Software-Testing-Basics/blob/master/%E7%AC%AC%E4%BA%8C%E7%AB%A0/2_4_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AF%A6%E8%A7%A3.md#-24---%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AF%A6%E8%A7%A3)

[**回到主页**](https://github.com/Lingggao/Software-Testing-Basics#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0)